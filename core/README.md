1. 회원 요구사항
   1. 회원가입, 조회
   2. 회원은 일반과 VIP 두 가지 등급이 있다.
   3. 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다.
2. 주문과 할인 정책
   1. 상품을 주문할 수 있다.
   2. 회원 등급에 따라 할인 정책을 적용할 수 있다.
   3. 할인은 VIP 는 1000원 할인
   4. 기본 할인은 아직 정하지 못했고, 오픈 직전까지 고민을 미룰예정, 최악의 경우 할인을 적용하지 않는다.

즉, 회원데이터와 할인 정책은 결정되지 않았다. => 인터페이스를 만들고 구현체를 언제든 갈아끼울 수 있는 설계를 하면된다.


1번째 수업. 회원을 구성해보자
1. Member 는 Entity 이다.
2. Member 의 정보를 다루는 Repository 를 하나 만든다(Interface), 그리고 interface 가 구현된 MemoryMemberRepository 를 생성한다
3. 이번엔 Service interface 를 만든다. 이것은 클라이언트가 입력한 정보를 다룬다. 그것을 ServiceImpl 을 통해 구현시킨다.
   3-1. 이때 객체를 생성하여 가진 정보를 어떻게 할지 도와주는 메소드인 MemoryMemberRepository 를 불러온다.
   3-2. 그리고 그곳에 있는 메소드로 Service 구현체를 완성한다.
4. 이렇게 만드는것이 과연 SOLID 의 원칙을 잘 적용이 된 것일까? 아니다 - 우리는 추상화(MemberRepository)와 구현체(MemoryMemberRepository)를 모두 의존하게 된다.
   이는 구현체를 의존하면 안된다는 DIP 를 위반하게 되는것이다.

2번째 수업. 주문서를 만들어보자
1. 주문을 하는 로직을 구성한다.
2. 먼저 할인을 하게 해주는 서비스 로직을 구현한다. DiscountPolicy 는 당연히 interface 이고 이를 구현하는 FixDiscountPolicy 로 할인을 진행한다.
3. 이제 클라이언트가 주문을 하면 해당 주문을 처리하는 Order interface 를 구성한다. Order interface 에는 FixDiscountPolicy 를 객체 생성하여 해당 메소드를 사용한다.
4. 이때 장점은 할인을 하는 로직과 주문을 받는 로직이 따로 구현되어 있기 때문에 할인이 망가지면 할인을 담당하는 로직 FixDiscountPolicy 만 바꾸면 다시 괜찮아진다.
5. 이제 Test 코드를 작성하여 우리가 만든 코드들 할인이 1000원이 맞는지 확인한다.

3번째 수업. 기획자의 등장! 새로운 할인 정책을 추가한다.
1. 악덕 기획자는 초기에 만든 1000원 할인을 없애고 할인율을 만들었다. 그렇다면 우리는 무엇을 해야할까?
2. 우선 할인율에 따른 할인가를 적용하기 위해 메소드를 만든다. 물론 인터페이스를 참고하여 만들것이다. 그렇게 만든 할인율을 가지고 Test 까지 돌리면서 우리가 만든 로직이 
   정상 작동하는지 잘 살펴본다.
3. 이제 적용해보자 orderServiceImpl 에서 적용해야한다. 변경된 할인 정책을 적용하려면 사용하고 있는 것을 지우고 RateDiscountPolicy 로 객체를 바꿔주어야한다
4. 하지만 여기서 아까 말한 객체 지향 설계 원칙 중 DIP 를 위배한 문제가 발생한다. 심지어 우리가 Fix 를 Rate 로 바꾸게 되면서 소스 코드를 변경한다.
   이때 클라이언트와 직접적으로 맞닿아 있는 ServiceImpl 을 건들여서 변경을 하게 되는것이다
   이는 설계 지향 원칙 중 OCP 를 위반하게 되는것이다. 즉, 아주 골고루 다양하게 위반중이다. 잘짜여진줄 알았는데...
   쉽게 말하면 배역(인터페이스)를 하는 배우(구현체)가 상대 배역(인터페이스)인 배우(구현체)를 직접 초빙하는것과 같이 구현체가 공연도 하고 초빙도 하는 다양한 책임을 지게 만든것이다. 
   결과적으로 우리는 인터페이스만 의존하게 만들어야 한다는것이다.
   그래서 OrderServiceImpl 여기에 보이는것처럼 인터페이스만 의존하게 만들면 그저 텅 빈 껍데기여서 구현이 안된다 그럼 어떻게 해야할까
   누군가가 OrderServiceImpl 에 DiscountPolicy 의 구현 객체를 대신 생성하고 주입해주어야 한다 그 방법을 알아보자

4번째 수업. 구현 객체를 대신 생성하고 주입해주는 방법 ( 공연 기획자 AppConfig 의 등장)
1. 배우는 연기하는것에 집중해야한다. 상대 배역이 바뀌더라도 상관이 없어야하는것이다. 공연을 구성하고, 담당 배우를 섭외하고, 역할에 맞는 배우를 지정하는 책임을 다른 누군가
   즉, 공연 기획자(AppConfig) 가 필요한것이다. 공연 기획자와 배우의 역할을 확실히 나누자
2. AppConfig 를 보면 이제 더이상 Impl 이 생성자 주입을 통해 구현체에 간섭하지 않는다는 것을 알 수 있다. 중간 단계의 Config 가 서로의 간섭의 연결고리가 되어서 진행한다.
3. 이제 클라이언트와 직접적으로 연결된 Impl 는 DIP 원칙인 추상화만 간섭하게 되었다라는것을 알수 있다.
4. Impl 의 입장에서 필요한 의존관계를 마치 외부에서 주입해주는 것 같다고해서 DI(Dependency Injection)이라고 한다. 이를 의존관계 주입이라고 한다.
5. 이로써 Impl 은 실행에만 집중하면 된다.

5번째 수업. AppConfig 를 눈에 띄게 쉽게 바꿔보자
1. 인자로 들어가있는 new 로 생성된 객체들을 각자 무슨 역할을 하는지 한눈에 보기 쉽게 정렬한다.
2. 이로써 사용영역과 구성 영역이 나뉘었다. 
3. 사용영역은 배우로써 공연이 어떻게 되었고 누굴 섭외해야할지는 고민할 필요가 없다 이 모든건 구성영역인 공연기획자가 신경쓰면 되는것이다.
4. 다만 공연기획자는 모든것을 알아야한다.

6번째 수업. 스프링으로 전환해보기
1. Config 에 @configuration 어노테이션을 붙여주었다. 그리고 각 메소드에 @Bean 을 붙여주면 스프링 컨테이너에 등록된다.
2. 그래서 이제 AppConfig 를 불러와서 직접 보고 확인하는것이 아닌 스프링 컨테이너에서 불러올수 있는것이다.
3. 그럼 그냥 AppConfig 를 사용하는거에서 왜 굳이 컨테이너에 저장해두는걸까? 어떤 장점이 있을까?

7번째 수업. 스프링 컨테이너에 등록된 빈 확인하기
1. Test 코드에 ApplicationContextInfoTest 를 통해 내가 만든 빈과 스프링이 필요에 의해 만든 빈을 확인해 볼 수 있다.

8번째 수업. 스프링 빈을 조회해보자
1. ApplicationContextBasicFindTest 이곳에서 다양한 방법을 통한 빈 등록을 확인할 수 있다.
2. 빈 이름이 두개 이상 일때 어떻게 해야할까?
   ApplicationContextSameBeanFindTest 파일을 보면 이해가 될 것이다.

9번째 수업. 스프링 빈의 상속관계
1. 상속 관계에 따른 빈을 확인하는 방법을 ApplicationContextExtendsFindTest 여기서 다양하게 확인하는 방법을 알아보자

10번째 수업. XMl 을 이용한 빈 설정하기
1. 클래스뿐 아니라 xml 을 기반으로도 빈을 생성할 수 있다. 방식은 xml 로 바뀌었을뿐 클래스와 똑같다

11번째 수업. BeanDefinition
1. 만들면서 한번쯤은 들었던 너무 다양한 빈 생성 방법이 있다. 근데 스프링은 어떻게 이걸 다 지원하는걸까?
2. 스프링 컨테이너는 오로지 BeanDefinition 에만 의존한다. BeanDefinition 은 추상화이다 즉, DIP 를 아주 잘 지켰다고 할 수 있다.
   그래서 컨테이너에 등록하는 방법이 뭐든 크게 상관이 없는것이다.
3. 우리가 흔히 사용하는 Config 에 어노테이션으로 컨테이너를 구성하는것이 팩토리메서드를 이용한다고 표현한다.

12번째 수업. Singleton 
1. 스프링을 웹서비스로 사용하는 특성은 수많은 객체 생성이 되고 이는 계속 메모리에 쌓인다.
2. 이는 정말 심각한 메모리 낭비라고 할 수 있다. 그래서 나온것이 Singleton 이 나왔다
3. Singleton 은 해당 객체가 딱 1개만 생성되고, 공유하도록 설계하면 되게 하는것이다.
4. 그래서 단 한개의 인스턴스만 생성되게 하는 디자인패턴이다. 어떻게 하는것 일까?
5. private 로 다른곳에서 객체 생성을 막고 그것을 함수로만 가져오게 만든다.
6. 하지만 이는 문제점이 있다.
   1. 코드를 일일히 작성해주어야한다.
   2. 의존관계상 클라이언트가 구체클래스에 의존해야한다. -> 클라이언트가 구체클래스에 의존해서 OCP 원칙을 위반한다.
   3. 테스트하기 까다롭다
   4. 내부 속성을 변경하거나 초기화 하기 어렵다.
   5. private 생성자로 자식 클래스를 만들기 어렵다.
   6. 결론적으로 유연성이 많이 떨어진다
   7. 안티패턴이라고도 불린다.
7. 이를 해결해주는것이 스프링 컨테이너이다. 객체 인스턴스를 싱글톤으로 관리한다. 딱히 복잡하지 않다 우리가 지금까지 한것이 싱글톤으로 관리해주는것이다.
8. 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 주의할 점이 있다.
   1. 절대 stateful 이 아닌 stateless 상태로 설계해야한다.
   2. 특정 클라이언트에 의존적인 핑드가 있으면 안된다
   3. 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다
   4. 가급적 읽기만 가능해야한다.
   5. 필드 대신에 자바에서 공유되지 않는, 지역변수 ,파라미터, ThreadLocal 등을 사용해야한다.

12번쨰 수업. 컴포넌트 스캔과 의존관계 자동 주입
1. 스프링 빈을 등록할때 설정 정보에 일일히 직접 등록하기는 굉장히 귀찮다. 정보가 커지면 커질수록 누락의 위험도 생긴다.
2. 그래서 설정 정보를 넣지 않아도 자동으로 스프링 빈으로 등록하는 컴포넌트 스캔이라는 기능을 제공한다.
3. 그것이 @Autowired 이다.



